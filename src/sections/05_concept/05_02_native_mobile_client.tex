\subsection{Nativer Mobile Client}

Mit IP5 wurde bereits ein Client umgesetzt.
Dieser muss für IP6 migiert werden.
Hier wird beschrieben, wie die bestehenden Anforderungen mit dem nativen client umgesetzt werden können.

\subsubsection{Benutzeroberfläche}

Die Ansichten zur Anmeldung und Zimmerauswahl werden analog zum bestehenden Mobile Client umgesetzt.
Die Login Seite beinhaltet einen kurzen Willkommenstext und ein Logo für Praxisruf.
Darunter findet sich ein einfaches Formular zur Eingabe von Benutzername und Passwort.

\begin{figure}[h]
    \centering
    \begin{minipage}[b]{0.4\textwidth}
        \includegraphics[width=\textwidth]{/home/joshua/FHNW/dev/IP6/IP6_Bachelorarbeit_Bericht_Cloudbasiertes_Praxisrufsystem/src/graphics/mockups/mockup_login}
        \caption{Mockup Login}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.4\textwidth}
        \includegraphics[width=\textwidth]{/home/joshua/FHNW/dev/IP6/IP6_Bachelorarbeit_Bericht_Cloudbasiertes_Praxisrufsystem/src/graphics/mockups/mockup_clientselect}
        \caption{Mockup Zimmerwahl}
    \end{minipage}\label{fig:Mockups-Login-ClientSelection}
\end{figure}

Die Zimmerauswahl besteht aus einem Seitentitel und einem Panel indem das gewünschte Zimmer ausgewählt werden kann.
In der Auswahl sind alle Zimmer zu sehen, welche dem Benutzer zur Verfügung stehen.
In der Kopfzeile sind die Schaltflächen ''Zurück'' und ''Fertig'' zu sehen.
Die Schaltfläche ''Zurück'', bricht die Anledung ab und führt zurück auf die Login Ansicht.
Die Schaltfläche ''Fertig'' bestätigt die Auswahl und leitet zur Hauptansicht weiter.
Wird bestätigt, ohne dass ein Zimmer angewählt ist, wird dem Benutzer eine Fehlermeldung angezeigt und nicht zur Hauptansicht weitergeleitet.

\clearpage

In der Hauptansicht gliedert sich in die Bereiche Home, Inbox und Einstellungen.
Zwischen den drei Bereichen kann über eine Leiste am unteren Ende des Bildschirms navigiert werden.
Die Ansicht Home zeigt dem Benutzer die Buttons, über welche er Meldungen versenden und Anrufe in der Gegensprechanlage starten kann.
Wird ein Anruf gestartet, wird die Ansicht für aktive Anrufe angezeigt.
Diese zeigt dem Benutzer den Titel des gestarteten Anrufs, sowie eine Liste aller Teilnehmer zusammen mit dem Verbindungsstatus jedes Teilnehmers.
Der Titel des Anrufes entspricht dem Anzeigetext des entsprechenden Buttons für ausgehende Anrufe und dem Namen des Anrufers für empfangene Anrufe.
Neben den Anrufinformationen zeigt die Ansicht für aktive Anrufe drei Buttons.
Über diese können Microfon und Lautsprecher des eigenen Gerätes stummgeschaltet werden.
Weiter kann über der Anruf über den dritten Button beendet werden.
Nach einem beendeten Anruf, wird zurück auf die Hauptansicht weitergeleitet.
Für den Anrufern ist das immer der Home Bereich.
Für den Empfänger entspricht es dem Bereich, der vor dem Empfang des Anrufes angezeigt wurde.

\begin{figure}[h]
    \centering
    \begin{minipage}[b]{0.4\textwidth}
        \includegraphics[width=\textwidth]{/home/joshua/FHNW/dev/IP6/IP6_Bachelorarbeit_Bericht_Cloudbasiertes_Praxisrufsystem/src/graphics/mockups/mockup_intercom}
        \caption{Mockup Home}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.4\textwidth}
        \includegraphics[width=\textwidth]{/home/joshua/FHNW/dev/IP6/IP6_Bachelorarbeit_Bericht_Cloudbasiertes_Praxisrufsystem/src/graphics/mockups/mockup_call}
        \caption{Mockup Aktiver Anruf}
    \end{minipage}\label{fig:Mockups-Home-ActiveCall}
\end{figure}

Der Bereich Inbox zeigt eine Liste der empfangenen Meldungen sowie der empfangenen und verpassten Anrufe.
Für Meldungen wird der Titel der Benachrichtigung gefolgt vom Namen des Versenders in Klammern sowie der Haupttext der Meldung angezeigt.
Für Anrufe wird der Name des Anrufers und ein Text der besagt ob es sich um einen empfangenen, verpassten oder abgelehnten Anruf handelt angezeigt.
Einträge für Meldungen sowie verpasste und abgelehnte Anrufe müssen durch antippen quittiert werden.
Solange unquittierte Meldungen oder Anrufe in der Inbox sind ertönt, wird im Abstand von 60 Sekunden eine Benachrichtigung angezeigt, die den Benutzer erinnert, die Inbox zu quittieren.
Der Bereich Settings zeigt den Namen des aktuellen Benutzers und ausgewählten Zimmers.
Über die Schaltfläche Abmelden, kann sich der Benutzer aus der Applikation abmelden.
Die Schaltfläche Benachrichtigungen vorlesen ist standardmässig aktiviert.
Wird die Option deaktiviert, werden Benachrichtigungen nie vorgelesen.
Die Schaltfläche Anruge empfangen ist ebenfalls standardmässig aktiviert.
Wird diese Option deaktiviert, werden alle empfangenen Anrufe automatisch abgelehnt und stattdessen eine Benachrichtigung angezeigt.
Ausgehende Anrufe können auch getätigt werden, wenn diese Option aktiviert ist.


\begin{figure}[h]
    \centering
    \begin{minipage}[b]{0.4\textwidth}
        \includegraphics[width=\textwidth]{/home/joshua/FHNW/dev/IP6/IP6_Bachelorarbeit_Bericht_Cloudbasiertes_Praxisrufsystem/src/graphics/mockups/mockup_inbox}
        \caption{Mockup Inbox}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.4\textwidth}
        \includegraphics[width=\textwidth]{/home/joshua/FHNW/dev/IP6/IP6_Bachelorarbeit_Bericht_Cloudbasiertes_Praxisrufsystem/src/graphics/mockups/mockup_settings}
        \caption{Mockup Einstellungen}
    \end{minipage}\label{fig:Mockups-Inbox-Settings}
\end{figure}


\subsubsection{Anbindung CloudService}

Der Mobile Client muss an die API des Cloudservices angebunden werden.
Es wird eine Anbindung an die Domäne Configuration zur Anmeldung und Auswahl des gewünschten Zimmers, an die Domäne Notification zum Versenden von Benachrichtigungen und an die Domäne Speech Synthesis für den Bezug von Sprachdaten benötigt.
Die Schnittstellen dieser Domänen stehen als REST Endpoints zur verfügung.
In diesem Unterkapitel wird beschrieben, wie REST Aufrufe im nativen iOS Client integriert werden sollen.\footnote{Die Anbindung der Domäne Signaling findet nicht über REST statt und ist im Kapitel 5.2.4 beschrieben.}

Die Basisbibliothek für iOS Entwicklung bietet die Klasse URLSession, über welche Netzwerkaufrufe getätigt werden können.
Über URLSession.shared steht zudem eine Standard Instanz zur Verfügung, über welche Anfragen erstellt werden können.\cite{ios_urlsession}
Die Klasse UrlRequest ermöglicht es, Http-Request für eine URL mit Header und Body zu erstellen.\cite{ios_urlrequest}
Um die Integration dieser Klassen in den Mobile Client zu vereinfach, wird ein zentraler Service mit dem Namen PraxisrufApi erstellt.
Dieser kapselt das Erstellen, Befüllen und Absetzten der nötigen UrlRequest Instanzen und bietet öffentliche für die Http Verben Get, Post und Delete an.

Der Basis des Api Service lädt die Basis URL für die Praxisruf API us der Umgebungskonfiguration.
Die http Methoden auf dem Basis Service nehmen eine subUrl für den Aufruf entgegen.
Diese wird der Basis Url angehängt.
Post und Put nehmen zudem einen Parameter data für den Inhalt des Request Bodies entgegen.
Aus diesen Informationen kann der Http Request gebaut und versendet werden.
Als letzten Parameter nehmen alle Methoden einen Parameter mit dem Namen completion entgegen.
Dabei handelt es sich um ein Callback, welches beim Erfolg oder Fehlschlagen der Anfrange an die API ausgeführt wird.

\lstinputlisting[caption=PraxisrufApi.swift,language=java,label={lst:praxisrufapi.swift}]{listings/praxisrufapi.swift}

Als Input Paramter dieses Callbacks wird immer der Typ Result<T, PraxisrufApiError> verwendet.
Bei Result handelt es sich um einen Wrapper Type der entweder als Erfolg oder Fehler instanziert werden kann.
Im Fehlerfall wird der Wrapper mit einem PraxisrufApiError Objekt instanziert.
Im Erfolgsfall wird der Wrapper mit einem Object vom Typ T instanziert.
Der Type T ist generisch und muss dem Decodable Protocol entsprechen.
Decodable Instanzen können von einer JSON Spring Repräsentation in ein Swift Object konvertiert werden.
So kann das Objekt im Erfolgsfall aus der Response generiert und an dass Callback übergeben werden.
Dadurch kann die Konvertierung generisch in der Basisklasse behandelt werden.
Innerhalb des Callbacks kann geprüft werden ob der Request erfolgreich war oder nicht und anhand des Inhalts die entsprechende Logik ausgeführt werden.
Dieser Ansatz ermöglicht es im Api Service ausschliesslich den API Call abzuhandeln.
Der Api Service muss keinen State führen und kann generisch für alle Anwendungen wiederverwendet werden.

Requests die über den Api Service erstellt werden, werden automatisch authorisiert.
Dazu lädt der Service die hinterlegten Credentials aus dem KeyStore von iOS und generiert einen entsprechenden Authorization Header.
Ist kein Token vorhanden wird der CompletionHandler mit einer entsprechenden Fehlermeldung aufgerufen.

Mit dieser Lösung steht ein Service zur verfügung, über welchen REST Calls einfach gemacht werden können.
Dank der generischen Methoden im Basis Service können neue Calls einfach hinzugefügt werden, ohne das Boilerplate Code wiederholt werden muss.
Durch die completion Methoden kann zudem jeder Call den Bedürfnissen des Aufrufers entsprechend abgehandelt werden.
Die Extension Klassen mit domänenspezifischen, sprechenden Methoden machen die verfügbaren Aufrufe übersichtlich.
Die API wird immer einheitlich über den generischen Service angesprochen.
Die Integration in den rest der Applikation über sprechende Namen führt dabei zu lesbarem und übersichtlicherem Code.

Pro Domäne die angesprochen wird, wird eine Extionsionklasse erstellt.
Diese bietet Methoden mit sprechenden Namen für die angesprochene Funktionalität.
Die Methoden darin rufen die get, post, put und delete Methoden des API Service mit den entsprechenden Parametern auf.

Der Service zur API Integration wird nicht direkt in den View Komponenten verwendet.
Es wird pro Domäne ein weiterer Service geschrieben, welche den Aufruf des API Services kapselt.
Dieser Service bietet Methoden, über welche der API Service angesprochen werden kann.
Die Methoden des Integration Services nehmen die Informationen, welche aus der Benutzeroberfläche Stammen als Parameter entgegen.
Sind Daten aus der aktuell aktiven Client COnfiguration für den Request nötig, werden diese im Integration Service aus den UserDefaults geladen.
Die Integration Services werden als ObservableObjects implementiert.
Die Resultate der API Calls werden im Service als Instanzvariable mit @Published gesetzt.
Die View, welche einen Integration Service verwendet, kann Bindings auf diese @Published Resultate setzten.

\subsubsection{Anbindung Messaging Service}

Als Messaging Service wird Firebase Cloud Messaging verwendet.
Firebase bietet eine native library mit welcher Firebase Cloud Messaging in iOS Clients integriert werden kann.
Diese Integration kann allerdings nicht mit dem Mitteln von SwiftUI implementiert werden.
Dies liegt daran, dass für das Empfangen von Benachrichtigungen und das Anzeigen von Push Benachrichtigungen Integration mit dem Betriebsystem notwendig ist.
Diese Integration kann bis heute nur über AppDelegates aus der UIKit Welt umgesetzt werden.
SwiftUI Applikationen können oft ohne AppDelegates implementiert werden.
Sobald aber Integration mit dem Betriebsystem notwendig ist, müssen AppDelegates verwendet werden.
Dazu können AppDelegates bei der Initialisierung der Applikation registriert werden.
Zur Anbindung von Firebase Cloud Messaging an den Mobile Client wird dementsprechend ein AppDelegate implementiert.
Die Logik des AppDelegates soll dabei auf das minimal nötige reduziert werden.
Der AppDelegate selbst ist für die direkte Kommunikation mit dem Messaging Service und Betriebssystem verantwortlich.
Alle weitere Logik wird nicht im AppDelegate selbst ausgeführt, sondern an die Applikation delegiert.
Dies ermöglicht es die Anbindung des MessagingServices im AppDelegate zu kapseln.
Was den wechsel auf einen Anderen Messaging Service in Zukfunft vereinfacht.
Weiter sorgt es dafür, dass die Fachlogik vollständig im SwiftUI Teil implementiert werden kann.
Der AppDelegate beinhaltet lediglich die Teile, welche aus technischen Gründen nicht mit SwiftUI umgesetzt werden können.

Die Implementation des AppDelegate muss damit folgende Anforderungen erfüllen.
Beim Start der Applikation muss sich der Mobile Client beim Messaging Service registrieren.
Nach der Registrierung wird für den Mobile Client ein Token generiert, welches den Client eindeutig beim Messaging Service identifiziert
Der App Delegate muss, darauf reagieren und das erneuerte Token an die Applikation übergeben.
Der AppDelegate muss weiter die Möglichkeit bieten, den Client beim Messaging Service abzumelden.
Für die Verarbeitung von Benachrichtigungen muss der AppDelegate Benachrichtigungen im Vordergrund empfangen und als Push Benachrichtigungen anzeigen können.
Die Informationen aus der Empfangenen Benachrichtigung müssen anschliessend an die Appliation übergeben werden.
Der AppDelegate muss weiter Benachrichtigungen im Hintergrund empfangen und als Push Benachrichtigung anzeigen können.
Sobald die Applikation wieder in den Vordergrund tritt, müssen die Daten dieser Benachrichtigung an die Applikation zur weitern Verarbeitung übergeben werden.

\subsubsection{Anbindung Singaling}

Für den Aufbau von Sprachverbindungen zwischen Mobile Clients müssen mehrere Signalmeldungen ausgetauscht werden.
Der Cloud Service wird im Rahmen dieses Projektes um eine Websocket Schnittstelle erweitert, welche dies ermöglicht.\footnote{Vgl. Kapitel 5.4}
Als Technologie für diese Schnittstelle werden Websockets verwendet.
Der Api Service wird dementsprechend erweitert, um Websocket Verbindungen zu ermöglichen.
Dies beinhaltet den Auf- und Abbau von Websocket Verbindungen, sowie das Senden und Empfangen von Meldungen über diese Verbindung.
Weiter muss die Verbindung konstant offen gehalten und im Fehlerfall erneut aufgebaut werden können.

Der Austausch von Signalmeldungen ist der einzige Anwendungsfall in Praxisruf, der Websocketverbindungen benötigt.
Deshalb wird auf eine generische Integration von Verbindungen analog von Http Verbindungen\footnote{Vgl. Kapitel 5.2.2} verzichtet.
Stattdessen wird eine Extension Klasse PraxisrufApi+Signaling nach folgendem Muster erstellt:

\lstinputlisting[caption=PraxisrufApi+Signaling.swift,language=java,label={lst:PraxisrufApi+Signaling.swift}]{listings/PraxisrufApi+Signaling.swift}

Die Signaling Extension kann immer genau eine offene Verbindung verwalten.
Diese wird als Instanzvariable innerhalb des Services geführt.
Der Status dieser Verbindung kann als Computed Property "disconnected" intern abgefragt werden.
Die Extension bietet Methoden um den Signaling Service zu Verbinden.
Eine Verbindung wird dabei immer spezifisch für die aktuell gewählte Client Configuration geöffnet. \footnote{Vgl. Kapitel X.X}
Weiter werden Methoden angeboten, um Pingsignale zu senden oder die Verbindung zu trennen.
Zudem bietet die Extension Methoden, um Signalmeldungen über die geöffnete Verbindung zu senden,
sowie eine Methode um empfangene Signalmeldungen zu verarbeiten.

Für die Integration der Singalingverbindung in den Rest der Applikation, wird das Protokoll PraxisrufApiSignalingDelegate definiert.

\lstinputlisting[caption=PraxisrufApiSignalingDelegate.swift,language=java,label={lst:PraxisrufApiSignalingDelegate.swift}]{listings/PraxisrufApiSignalingDelegate.swift}

Vor dem Versenden einer Signal- oder Pingmeldung wird überprüft, ob eine Verbindung geöffnet und Fehlerfrei ist.
Ist dies nicht der Fall, wird die Verarbeitung die onConnectionLostMethode des Delegates aufgerufen.
Die Implementation dieses Delegates ist dafür verantwortlich, die Verbindung wieder zu öffnen.
Die Methoden onSignalReceived resp. onErrorReceived werden aufgerufen wenn ein Signal resp. eine Fehlermeldung empfangen wurde.
Im Fehlerfall soll wenn nötig eine Fehlermeldung angezeigt werden und die Verbindung repariert werden.
Wenn eine Signalmeldung empfangen wurde, muss diese an die Applikation zu Verarbeitung weitergereicht werden.

\subsubsection{Integration Sprachverbindung}

Neben austausch von Signalen muss auch die Sprachverbindung selbst verwaltet werden.
Die Details der Sprachverbindung sind vendor spezifisch.
Es wird deshalb eine eigene Klasse CallClient erstellt.
Diese ist für das Verwalten von Verbindungen verantwortlich.
Bei eingehenden Verbindungen muss sie signale empfangen, die Verbindung erstellen.
Wenn nötig Antowrt Signale erstellen und zurückgeben.
Bei ausgehenden Verbindungen muss sie Verbindung initialisieren.
Es muss Signal erstellt und versendet werden.
Weiter müssen Methoden angeboten werden um die Unterhaltung oder das Microphon zu muten.
Und um die Verbindung zu schliessen.
Und um den bei Änderung des internen Status, das UI entsprechend zu aktualisieren.

Um die Integration der Sprachverbindung möglichst unabhängig und auswechselbar zu machen, wird der CalLClient nicht direkt in der View verwendet.
Stattdessen definiert der CallClient ein Delegate Protocol, welches die notwendigen Callbacks definiert.

\lstinputlisting[caption=CallClientDelegate.swift,language=java,label={lst:CallClientDelegate.swift}]{listings/CallClientDelegate.swift}

Es wird eine Klass CalService erstellt.
Der CallService instanziert den CallClient sowie den Signaling Client.
Er implementiert die beiden Delegate Protocols und registriert sich als Delegate bei den beiden Services.
Beim Empfangen von Benachrichtigungen können Signale so vom Signaling Client über den Call Service an den Client gelangen.
Beim Versenden von Benachrichtigungen können Signale von Call Client über den Call Service an den Signaling Client versendet werden.
Neben den Funktionen zur Integration von Call Client und Signaling Client, bietet führt der CallService die States die in der Benutzeroberfläche angezeigt werden.
Dies beinhaltet den Status und Teilnehmer des aktiven Anrufes sowie Status von Lautsprecher und Microphon.
Der Service wird in der View Komponente für Anrufe verwendet.
Die View kann über den Service die Sprachverbindung stummschalten oder beenden.


\\


\subsubsection{Scheduled Reminder für Inbox}
IOS Development unterstützt scheduled tasks.

\clearpage
